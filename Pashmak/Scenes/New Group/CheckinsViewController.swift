//
//  CheckinsViewController.swift
//  Pashmak
//
//  Created by Mohammad Porooshani on 9/25/18.
//  Copyright (c) 2018 Mohammad Porooshani. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import Async
import Hero
import IGListKit
import KVNProgress
import Material
import UIKit
import VisualEffectView

protocol CheckinsDisplayLogic: AnyObject {
  func displayPopulateLoading(viewModel: Checkins.Populate.ViewModel.Loading)
  func displayPopulateFailed(viewModel: Checkins.Populate.ViewModel.Failed)
  func displayPopulateSuccess(viewModel: Checkins.Populate.ViewModel.Success)

  func displayCheckinLoading(viewModel: Checkins.Checkin.ViewModel.Loading)
  func displayCheckinFailed(viewModel: Checkins.Checkin.ViewModel.Failed)
  func displayCheckinSuccess(viewModel: Checkins.Checkin.ViewModel.Success)

  func displayUpdateCheckinNeeded(viewModel: Checkins.UpdateCheckinNeeded.ViewModel)
}

class CheckinsViewController: UIViewController {
  var interactor: CheckinsBusinessLogic?
  var router: (NSObjectProtocol & CheckinsRoutingLogic & CheckinsDataPassing)?
  var displayedItems: [ListDiffable] = []
  // MARK: Object lifecycle

  override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
    super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
    setup()
  }

  required init?(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)
    setup()
  }

  // MARK: Setup

  private func setup() {
    let viewController = self
    let interactor = CheckinsInteractor()
    let presenter = CheckinsPresenter()
    let router = CheckinsRouter()
    viewController.interactor = interactor
    viewController.router = router
    interactor.presenter = presenter
    presenter.viewController = viewController
    router.viewController = viewController
    router.dataStore = interactor
  }

  // MARK: Routing

  override func prepare(for segue: UIStoryboardSegue, sender: Any?) {
    if let scene = segue.identifier {
      let selector = NSSelectorFromString("routeTo\(scene)WithSegue:")
      if let router = router, router.responds(to: selector) {
        router.perform(selector, with: segue)
      }
    }
  }

  // MARK: View lifecycle

  @IBOutlet private weak var checkinButton: PulseView!
  @IBOutlet private weak var checkinButtonWidthConstraint: NSLayoutConstraint!
  @IBOutlet private weak var submitButtonLeadingConstraint: NSLayoutConstraint!
  @IBOutlet private weak var submitButtonLabel: UILabel!

  let updater = ListAdapterUpdater()
  lazy var adapter: ListAdapter = {
    let adapter = ListAdapter(updater: self.updater, viewController: self, workingRangeSize: 5)
    return adapter
  }()

  lazy var refreshControl: UIRefreshControl = {
    let refCon = UIRefreshControl()
    refCon.addTarget(self, action: #selector(self.populate), for: .valueChanged)
    refCon.tintColor = #colorLiteral(red: 0.3725490196, green: 0.3725490196, blue: 0.3725490196, alpha: 1)
    return refCon
  }()

  deinit {
    NotificationCenter.default.removeObserver(self)
  }

  override func viewDidLoad() {
    super.viewDidLoad()
    prepareUI()
    prepareObservers()
  }

  override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)
    if displayedItems.isEmpty {
      self.populate()
    }
    checkinUpdate()
  }

  private func prepareUI() {
    prepareNavBar()
    prepareCollectionView()
    prepareCheckinButton()
  }

  private func prepareObservers() {
    NotificationCenter.default.addObserver(self, selector: #selector(self.populate), name: NSNotification.Name.Pashmak.checkinUpdated, object: nil)
    NotificationCenter.default.addObserver(self, selector: #selector(self.checkinUpdate), name: NSNotification.Name.Pashmak.checkinUpdated, object: nil)
  }

  private func prepareNavBar() {
    let navbar = self.navigationItem
    navbar.titleLabel.text = "ترددها"
    navbar.titleLabel.textColor = .white
    navbar.titleLabel.font = UIFont.farsiFont(.bold, size: 16.0)
    self.navigationController?.navigationBar.tintColor = .white
    let blurView = VisualEffectView(effect: UIBlurEffect(style: UIBlurEffect.Style.regular))
    blurView.colorTint = #colorLiteral(red: 0.9607843137, green: 0.6509803922, blue: 0.137254902, alpha: 1)
    blurView.colorTintAlpha = 0.85
    blurView.blurRadius = 8.0
    blurView.scale = 2.0
    self.view.layout(blurView).top().left().right().height(64.0)
  }

  private func prepareCollectionView() {
    let layout = ListCollectionViewLayout(stickyHeaders: false, scrollDirection: UICollectionView.ScrollDirection.vertical, topContentInset: 0.0, stretchToEdge: false)
    let collectionView = UICollectionView(frame: .zero, collectionViewLayout: layout)
    let topOffset: CGFloat = 8.0
    collectionView.backgroundColor = .clear
    collectionView.isScrollEnabled = true
    collectionView.scrollIndicatorInsets.top = topOffset
    collectionView.contentInset.top = topOffset
    collectionView.contentInset.bottom = 64.0
    collectionView.layer.setShadow(opacity: 0.15, radius: 8.0)
    collectionView.refreshControl = self.refreshControl
    adapter.collectionView = collectionView
    adapter.scrollViewDelegate = self
    adapter.dataSource = self
    guard let containerView = self.view else {
      return
    }
    containerView.backgroundColor = #colorLiteral(red: 0.9490196078, green: 0.9490196078, blue: 0.9490196078, alpha: 1)
    collectionView.frame = containerView.bounds
    containerView.addSubview(collectionView)
    collectionView.autoresizingMask = [.flexibleWidth, .flexibleHeight]
    self.view.sendSubviewToBack(collectionView)
  }

  private func prepareCheckinButton() {
    guard let button = self.checkinButton else {
      return
    }
    self.view.bringSubviewToFront(button)
    button.layer.cornerRadius = 24.0
    button.depthPreset = .depth3
    button.pulseColor = .white
    button.isUserInteractionEnabled = true
    let tapGesture = UITapGestureRecognizer(target: self, action: #selector(self.checkIn))
    button.addGestureRecognizer(tapGesture)
  }

  @objc
  func populate() {
    Async.main { [weak self] in
      guard let self = self else {
        return
      }

      let request = Checkins.Populate.Request()
      self.interactor?.populate(request: request)
    }
  }

  @objc
  private func checkIn() {
    Async.main { [weak self] in
      guard let self = self else {
        return
      }

      let request = Checkins.Checkin.Request()
      self.interactor?.checkin(request: request)
    }

  }

  @objc
  private func checkinUpdate() {
    Async.main { [weak self] in
      guard let self = self else {
        return
      }

      let request = Checkins.UpdateCheckinNeeded.Request()
      self.interactor?.checkCheckinNeeded(request: request)
    }

  }

  private func updateChecckinUpdate(canCheckin: Bool) {

    self.checkinButton.isUserInteractionEnabled = canCheckin
    UIView.animate(withDuration: 0.35,
                   delay: 0.0,
                   usingSpringWithDamping: 0.7,
                   initialSpringVelocity: 6.0,
                   options: [],
                   animations: { [weak self] in
                    guard let self = self else {
                      return
                    }
                    self.checkinButton.transform = canCheckin ? .identity : CGAffineTransform(translationX: -130.0, y: 0.0)
                    self.checkinButton.backgroundColor = canCheckin ? #colorLiteral(red: 0.937254902, green: 0.6196078431, blue: 0.1019607843, alpha: 1) : #colorLiteral(red: 0.7294117647, green: 0.7294117647, blue: 0.7294117647, alpha: 1)
      }, completion: nil)
  }

}

extension CheckinsViewController: CheckinsDisplayLogic {
  func displayPopulateLoading(viewModel: Checkins.Populate.ViewModel.Loading) {
    if self.displayedItems.isEmpty {
      let items = viewModel.items
      self.displayedItems = items
      self.adapter.performUpdates(animated: true, completion: nil)
    }

  }

  func displayPopulateFailed(viewModel: Checkins.Populate.ViewModel.Failed) {
    self.refreshControl.endRefreshing()
    let message = viewModel.message
    KVNProgress.showError(withStatus: message)
  }

  func displayPopulateSuccess(viewModel: Checkins.Populate.ViewModel.Success) {
    let items = viewModel.items
    self.displayedItems = items
    self.adapter.performUpdates(animated: true) { [weak self] _ in
      guard let self = self else {
        return
      }
      self.refreshControl.endRefreshing()
    }
  }

  func displayUpdateCheckinNeeded(viewModel: Checkins.UpdateCheckinNeeded.ViewModel) {
    let checkinNeeded = viewModel.canCheckin
    updateChecckinUpdate(canCheckin: checkinNeeded)
  }

  func displayCheckinLoading(viewModel: Checkins.Checkin.ViewModel.Loading) {
    let message = viewModel.message
    KVNProgress.show(withStatus: message)
  }

  func displayCheckinFailed(viewModel: Checkins.Checkin.ViewModel.Failed) {
    let message = viewModel.message
    KVNProgress.showError(withStatus: message)
  }

  func displayCheckinSuccess(viewModel: Checkins.Checkin.ViewModel.Success) {
    let message = viewModel.message

    func updateForCheckin() {
      updateChecckinUpdate(canCheckin: false)
    }

    if !message.isEmpty {
      KVNProgress.showSuccess(withStatus: message) {
        updateForCheckin()
      }
    } else {
      KVNProgress.dismiss {
        updateForCheckin()
      }
    }

  }
}

extension CheckinsViewController: ListAdapterDataSource {

  func objects(for listAdapter: ListAdapter) -> [ListDiffable] {
    return self.displayedItems
  }

  func listAdapter(_ listAdapter: ListAdapter, sectionControllerFor object: Any) -> ListSectionController {
    switch object {
    case is ServerModels.Checkin.ListItem:
      return CheckinsListSectionController()
    default:
      fatalError("Unknown object for section controller: [\(object)]")
    }
  }

  func emptyView(for listAdapter: ListAdapter) -> UIView? {
    return nil
  }

}

extension CheckinsViewController: UIScrollViewDelegate {

  func scrollViewDidScroll(_ scrollView: UIScrollView) {
    let position = max(0, scrollView.contentOffset.y + scrollView.contentInset.top + 64.0)
    let maxWidth: CGFloat = 66.0
    let minWidth: CGFloat = 48.0
    let maxPosition: CGFloat = 264.0

    let progress = min(max(maxPosition - position, 0.0) / maxPosition, 1.0)
    let widthDiff = progress * maxWidth

    let width = minWidth + widthDiff

    self.submitButtonLabel.alpha = progress
    self.submitButtonLabel.font = UIFont.farsiFont(.light, size: 8.0 + (4.0 * progress))
    self.checkinButtonWidthConstraint.constant = width
    self.submitButtonLeadingConstraint.constant = 16.0 + (1.0 - progress) * -4.0
  }

}
